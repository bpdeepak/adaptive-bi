import React, { createContext, useContext, useState, useEffect, useRef, useCallback } from 'react';
import { dashboardAPI, metricsAPI, aiAPI } from '../services/api';

const DataContext = createContext();

export const useData = () => {
  const context = useContext(DataContext);
  if (!context) {
    throw new Error('useData must be used within a DataProvider');
  }
  return context;
};

export const DataProvider = ({ children }) => {
  const [state, setState] = useState({
    dashboardData: null,
    salesData: null,
    productData: null,
    customerData: null,
    aiInsights: null,
    isLoading: false,
    error: null,
    lastUpdated: null
  });

  // Prevent multiple simultaneous loads
  const isLoadingRef = useRef(false);
  const mountedRef = useRef(true);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      mountedRef.current = false;
    };
  }, []);

  // Function to safely make API calls with proper error handling
  const safeAPICall = async (apiCall, dataType) => {
    try {
      console.log(`🔄 Making API call for ${dataType}...`);
      const result = await apiCall();
      console.log(`✅ ${dataType} API call successful:`, result);
      return { success: true, data: result };
    } catch (error) {
      console.error(`❌ ${dataType} API call failed:`, error);
      return { 
        success: false, 
        error: error.message || `Failed to fetch ${dataType}`,
        details: error
      };
    }
  };

  // Load all data from real APIs (optimized)
  const loadAllData = useCallback(async () => {
    // Prevent multiple simultaneous loads
    if (isLoadingRef.current) {
      console.log('🔄 Data loading already in progress, skipping...');
      return;
    }

    console.log('🚀 Starting to load all data from real APIs...');
    
    isLoadingRef.current = true;
    
    if (!mountedRef.current) return;
    
    setState(prev => ({ 
      ...prev, 
      isLoading: true, 
      error: null 
    }));

    try {
      // Make all API calls in parallel with staggered timing to avoid rate limits
      const results = await Promise.allSettled([
        safeAPICall(() => dashboardAPI.getStats(), 'Dashboard Stats'),
        // Add small delays between calls to prevent rate limiting
        new Promise(resolve => setTimeout(() => resolve(safeAPICall(() => metricsAPI.getSales(), 'Sales Data')), 100)),
        new Promise(resolve => setTimeout(() => resolve(safeAPICall(() => metricsAPI.getProducts(), 'Product Data')), 200)),
        new Promise(resolve => setTimeout(() => resolve(safeAPICall(() => metricsAPI.getCustomers(), 'Customer Data')), 300)),
        new Promise(resolve => setTimeout(() => resolve(safeAPICall(() => aiAPI.getStatus(), 'AI Status')), 400))
      ]);

      if (!mountedRef.current) return;

      // Process results
      const newState = {
        isLoading: false,
        lastUpdated: new Date().toISOString(),
        error: null
      };

      let hasErrors = false;
      const errors = [];

      // Process each result
      results.forEach((result, index) => {
        const dataTypes = ['Dashboard Stats', 'Sales Data', 'Product Data', 'Customer Data', 'AI Status'];
        const stateKeys = ['dashboardData', 'salesData', 'productData', 'customerData', 'aiInsights'];
        
        if (result.status === 'fulfilled' && result.value.success) {
          newState[stateKeys[index]] = result.value.data;
          console.log(`✅ ${dataTypes[index]} loaded successfully`);
        } else {
          hasErrors = true;
          const errorMsg = result.status === 'rejected' ? result.reason.message : result.value.error;
          errors.push(`${dataTypes[index]}: ${errorMsg}`);
          console.error(`❌ ${dataTypes[index]} failed to load:`, errorMsg);
        }
      });

      if (hasErrors) {
        newState.error = `Some data failed to load: ${errors.join(', ')}`;
      }

      setState(prev => ({ 
        ...prev, 
        ...newState
      }));

      console.log('🎉 Data loading completed!', { hasErrors, errors });

    } catch (error) {
      console.error('❌ Critical error loading data:', error);
      if (mountedRef.current) {
        setState(prev => ({ 
          ...prev, 
          isLoading: false,
          error: `Critical error: ${error.message}`
        }));
      }
    } finally {
      isLoadingRef.current = false;
    }
  }, []);

  // Refresh specific data type (optimized)
  const refreshData = useCallback(async (dataType) => {
    console.log(`🔄 Refreshing ${dataType} data...`);
    
    if (!mountedRef.current) return;
    
    setState(prev => ({ ...prev, isLoading: true }));

    try {
      let result;
      
      switch (dataType) {
        case 'dashboard':
          result = await safeAPICall(() => dashboardAPI.getStats(), 'Dashboard Stats');
          if (result.success && mountedRef.current) {
            setState(prev => ({ 
              ...prev, 
              dashboardData: result.data,
              isLoading: false,
              lastUpdated: new Date().toISOString()
            }));
          }
          break;
          
        case 'sales':
          result = await safeAPICall(() => metricsAPI.getSales(), 'Sales Data');
          if (result.success && mountedRef.current) {
            setState(prev => ({ 
              ...prev, 
              salesData: result.data,
              isLoading: false,
              lastUpdated: new Date().toISOString()
            }));
          }
          break;
          
        case 'products':
          result = await safeAPICall(() => metricsAPI.getProducts(), 'Product Data');
          if (result.success && mountedRef.current) {
            setState(prev => ({ 
              ...prev, 
              productData: result.data,
              isLoading: false,
              lastUpdated: new Date().toISOString()
            }));
          }
          break;
          
        case 'customers':
          result = await safeAPICall(() => metricsAPI.getCustomers(), 'Customer Data');
          if (result.success && mountedRef.current) {
            setState(prev => ({ 
              ...prev, 
              customerData: result.data,
              isLoading: false,
              lastUpdated: new Date().toISOString()
            }));
          }
          break;
          
        case 'ai':
          result = await safeAPICall(() => aiAPI.getStatus(), 'AI Status');
          if (result.success && mountedRef.current) {
            setState(prev => ({ 
              ...prev, 
              aiInsights: result.data,
              isLoading: false,
              lastUpdated: new Date().toISOString()
            }));
          }
          break;
          
        default:
          console.error(`Unknown data type: ${dataType}`);
          if (mountedRef.current) {
            setState(prev => ({ ...prev, isLoading: false }));
          }
      }

      if (!result?.success && mountedRef.current) {
        setState(prev => ({ 
          ...prev, 
          isLoading: false,
          error: result?.error || `Failed to refresh ${dataType} data`
        }));
      }

    } catch (error) {
      console.error(`Error refreshing ${dataType} data:`, error);
      if (mountedRef.current) {
        setState(prev => ({ 
          ...prev, 
          isLoading: false,
          error: `Failed to refresh ${dataType}: ${error.message}`
        }));
      }
    }
  }, []);

  // Load data on mount (only once)
  useEffect(() => {
    console.log('📊 DataContext mounted - loading initial data...');
    loadAllData();
  }, [loadAllData]);

  const value = {
    ...state,
    loadAllData,
    refreshData,
    isUsingRealData: true, // We only use real data now
    isUsingMockData: false
  };

  return (
    <DataContext.Provider value={value}>
      {children}
    </DataContext.Provider>
  );
};
